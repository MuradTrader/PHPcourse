**1. Как PHP выполняет код (очень упрощенно):**

Представьте, что PHP - это переводчик, который читает ваш скрипт (текстовый файл `.php`) и выполняет его шаг за шагом. Процесс можно разделить на этапы:

- **Этап 1: Запуск интерпретатора.** Веб-сервер (например, Apache или Nginx) получает запрос на файл `.php`. Он запускает модуль PHP (интерпретатор) и передает ему этот файл.

- **Этап 2: Лексический анализ (Tokenizing).** PHP читает исходный текст файла и разбивает его на мелкие значимые части, называемые **токенами** (tokens). Например:

- Ключевые слова (`echo`, `if`, `function`)

- Идентификаторы (имена переменных, функций)

- Операторы (`=`, `.`, `+`)

- Литералы (строки `'hello'`, числа `42`)

- Скобки, точки с запятой и т.д.

- **Строки** распознаются как отдельные токены целиком, включая их кавычки.

- **Этап 3: Синтаксический анализ (Parsing).** PHP использует токены, чтобы построить **Абстрактное Синтаксическое Дерево (AST)**. Это внутренняя структура данных, которая представляет логическую структуру вашей программы. На этом этапе проверяется, соответствует ли последовательность токенов правилам грамматики PHP (например, после `echo` должно следовать выражение, после `if` - условие в скобках и т.д.).

- **Этап 4: Компиляция в Opcodes.** AST преобразуется в последовательность низкоуровневых инструкций, понятных виртуальной машине PHP (Zend Engine). Эти инструкции называются **opcodes** (операционные коды). Каждая высокоуровневая конструкция PHP (вроде `echo`, присваивание переменной, цикл `for`) разбивается на один или несколько opcodes.

- **Этап 5: Выполнение Opcodes.** Виртуальная машина Zend Engine выполняет opcodes последовательно. Именно на этом этапе:

- Выделяется память под переменные.

- Выполняются математические операции.

- Вызываются функции.

- Выводится текст с помощью `echo`.

- **Для строк:** В зависимости от типа кавычек (`'` или `"`), выполняются разные действия по их обработке (см. ниже).

- **Этап 6: Завершение.** После выполнения всех opcodes или при встрече фатальной ошибки, интерпретатор завершает работу. Выделенная память (для большинства переменных) освобождается. Результат выполнения (обычно сгенерированный HTML) отправляется веб-серверу, который пересылает его браузеру пользователя.

**2. Строки "под капотом" (в контексте выполнения opcodes):**

Когда виртуальная машина Zend Engine доходит до opcode, который работает со строкой (например, `ASSIGN` для присваивания переменной или `ECHO` для вывода), вот что происходит в зависимости от типа кавычек:

- **Строки в Одинарных Кавычках (`'текст'`):**

1.  **Токенизация:** На этапе лексического анализа весь текст между `'` и `'` (за исключением экранированных `\'` и `\\`) распознается как один токен `T_CONSTANT_ENCAPSED_STRING`.

2.  **AST:** В AST узел строки просто хранит последовательность символов внутри кавычек (с уже обработанными экранированными символами `\'` -> `'` и `\\` -> `\`).

3.  **Opcodes/Выполнение:** Когда виртуальная машина выполняет инструкцию для создания этой строки (например, `ASSIGN` для присваивания ее переменной), она **незамедлительно** создает в памяти строковый объект (`zend_string`), содержащий _буквально_ те символы, которые были между кавычками. Никаких дополнительных проверок или преобразований не производится.

- `$a = 'Hello $name \n';`

- В памяти переменной `$a` будет записана строка: `Hello $name \n` (символ `$`, слово `name`, пробел, обратная косая `\`, буква `n`).

- Никакой подстановки значения переменной `$name` не происходит. Никакой замены `\n` на символ переноса строки не происходит.

- **Строки в Двойных Кавычках (`"текст"`):**

1.  **Токенизация:** Весь текст между `"` и `"` распознается как токен `T_CONSTANT_ENCAPSED_STRING`. Однако, внутри этого текста PHP отмечает (`$`) и (`\`) как особые символы.

2.  **AST:** Узел строки в AST помечается как "интерполируемая строка".

3.  **Opcodes/Выполнение (Ключевое отличие!):** Виртуальная машина понимает, что эту строку нужно _обработать_ перед тем, как использовать. Выполняются следующие шаги:

- **Сканирование на переменные:** Двигаясь по строке, виртуальная машина ищет символ `$`. Когда он найден:

- Если за `$` следует допустимый символ имени переменной (буква, цифра, подчеркивание), виртуальная машина пытается прочитать имя переменной до первого недопустимого символа.

- Если используется синтаксис `{$var}`, виртуальная машина точно знает границы имени переменной (`var`).

- Виртуальная машина **выполняет поиск переменной** с этим именем в текущей области видимости (символической таблице). Если переменная не найдена, генерируется предупреждение (`Warning: Undefined variable`), и вместо значения подставляется пустая строка (`""`) или `null` (в зависимости от версии PHP и настроек).

- Значение найденной переменной **преобразуется в строку** (если это не строка изначально). Например, число `42` станет строкой `"42"`, `true` станет `"1"`, `false` и `null` станут `""` (пустой строкой).

- **Подстановка:** Найденное строковое значение вставляется на место `$var` или `{$var}` в итоговой строке.

- **Обработка Escape-последовательностей:** Одновременно с поиском переменных (или после него) виртуальная машина сканирует строку на наличие обратного слеша `\`. Если он найден, виртуальная машина смотрит на следующий за ним символ и выполняет замену:

- `\"` -> `"` (двойная кавычка)

- `\\` -> `\` (один обратный слеш)

- `\$` -> `$` (знак доллара - чтобы использовать его как символ, а не начало переменной)

- `\n` -> `символ с ASCII-кодом 10` (перевод строки - LF)

- `\r` -> `символ с ASCII-кодом 13` (возврат каретки - CR)

- `\t` -> `символ с ASCII-кодом 9` (табуляция)

- Для других символов после `\` (например, `\x`) могут быть другие замены (шестнадцатеричные коды), но `\a`, `\b` и т.д. обычно не обрабатываются и могут выдавать предупреждение или интерпретироваться буквально.

- **Сборка итоговой строки:** Виртуальная машина объединяет все части: обычный текст до первой переменной или `\`, значение подставленной переменной, текст после переменной до следующей переменной или `\`, результат замены escape-последовательности и т.д. Результат этой сборки (`конкатенации на лету`) сохраняется в памяти как новый строковый объект (`zend_string`).

- `$name = "John"; $b = "Hello $name!\nNew line.";`

- В памяти переменной `$b` будет записана строка: `Hello John!`, затем символ перевода строки (ASCII 10), затем `New line.`.

**3. Почему одинарные кавычки иногда "быстрее"?**

- **На этапе выполнения (opcodes):** Строка в одинарных кавычках создается в памяти сразу в своем финальном виде одним действием. Строку в двойных кавычках виртуальная машина должна _обработать_: найти переменные, найти их значения, преобразовать значения в строки, найти и заменить escape-последовательности, собрать итоговую строку из кусочков. Это требует больше операций процессора.

- **Но!** Разница в скорости в современных версиях PHP (7.x, 8.x) на одном вызове микроскопическая (наносекунды). Она становится заметной _только_ если вы обрабатываете гигантские строки с множеством переменных или выполняете операцию миллионы раз в очень плотном цикле. Для 99.9% веб-приложений эта разница несущественна.

- **Основная рекомендация использовать `'` по умолчанию:** Это не столько из-за скорости, сколько из-за **явности** и **предсказуемости**. Если вы знаете, что в строке нет переменных, использование `'` сразу дает понять другим программистам (и вам в будущем) и самому интерпретатору PHP, что никакой магии подстановки или замены спецсимволов здесь не ожидается. Это делает код немного чище и защищает от случайных ошибок, если в строке окажется `$` или `\`, которые вы не хотели интерпретировать.

**4. Конкатенация (`.`) vs Интерполяция (`" ... $var ... "`):**

- **Конкатенация (`'str1' . $var . 'str2'`):**

1.  Виртуальная машина создает строковый объект для `'str1'`.

2.  Виртуальная машина получает значение `$var` и преобразует его в строку (если нужно), создавая новый строковый объект.

3.  Виртуальная машина создает строковый объект для `'str2'`.

4.  Виртуальная машина выполняет операцию конкатенации над результатом шагов 1 и 2, создавая _еще один_ новый строковый объект (`temp1` = `'str1' + string($var)`).

5.  Виртуальная машина выполняет операцию конкатенации над `temp1` и результатом шага 3, создавая _финальный_ строковый объект (`result` = `temp1 + 'str2'`).

- **Интерполяция (`"str1{$var}str2"`):**

1.  Виртуальная машина начинает сборку итоговой строки.

2.  Она добавляет `'str1'` в буфер.

3.  Она получает значение `$var`, преобразует его в строку и добавляет эту строку в буфер.

4.  Она добавляет `'str2'` в буфер.

5.  Она создает _один_ финальный строковый объект из содержимого буфера.

- **Сравнение:** Интерполяция потенциально может быть эффективнее, так как:

- Позволяет избежать создания промежуточных строковых объектов (как `temp1` в конкатенации).

- Выполняет преобразование в строку и вставку за один проход в буфер.

- Код с интерполяцией часто гораздо читабельнее, чем длинные цепочки конкатенации.

- **Рекомендация:** Для объединения строк и переменных внутри сложных выражений предпочитайте интерполяцию в двойных кавычках с фигурными скобками (`" ... {$var} ... "`) из-за читаемости. Для простых случаев (2-3 элемента) или если нужно явно контролировать тип (например, использовать `strval($var)`), конкатенация тоже приемлема. Производительность сравнима в большинстве случаев.

**5. `\n` vs `<br>` - Глубже в Детали Вывода:**

- **`echo "\n";`:**

- На этапе выполнения PHP создает строку, содержащую байт с кодом `10` (LF).

- Эта строка (байт `10`) передается веб-серверу как часть выходных данных (output body) скрипта PHP.

- Веб-сервер отправляет этот байт браузеру клиента внутри HTTP-ответа.

- **В консоли (командная строка):** Терминал получает байт `10` и интерпретирует его как команду "переместить курсор на следующую строку". Перенос строки виден.

- **В браузере (просмотр HTML):** Браузер получает байт `10` как часть текста HTML-страницы. Согласно спецификации HTML, пробельные символы (пробелы, табуляции, переносы строк) **коллапсируются**. Это означает, что последовательности таких символов заменяются на **один пробел**, если только текст не находится внутри тега `<pre>` или не имеет CSS-стиля `white-space: pre;`/`pre-line;`. Поэтому в отрендеренной странице `\n` обычно превращается в невидимый пробел или ничего.

- **View Page Source (Исходный код страницы):** Когда вы используете эту функцию браузера, он показывает исходный HTML _таким, каким он был получен от сервера_. Здесь байт `10` отображается как видимый перенос строки. Это чисто текстовое представление исходника.

- **`echo "<br>";`:**

- PHP создает строку `"<br>"`.

- Эта строка передается веб-серверу и далее браузеру.

- Браузер, как парсер HTML, встречает тег `<br>`. Согласно спецификации HTML, этот тег означает **line break** (перенос строки). Браузер прерывает текущую строку текста и продолжает отображать последующий контент с начала следующей строки в видимой области страницы.

- В исходном коде страницы (View Page Source) вы увидите текст `"<br>"`.

**Итоговый мысленный эксперимент с кодом:**

Рассмотрим код:

```php

$user = "Аня";

$message = 'Привет, $user!\nКак дела?';

echo $message . "\n" . "<br>";

echo "Привет, {$user}!\n<br>Как дела?";

```

**Как это выполняется PHP "под капотом":**

1.  **`$user = "Аня";`**

- Токенизация: `$user`, `=`, `"Аня"`, `;`.

- AST: Узел присваивания переменной `user` строки `"Аня"`.

- Opcodes: `ASSIGN` - создать строку `"Аня"` и записать её в символьную таблицу под именем `user`.

- В памяти: Появилась переменная `$user` типа `string` со значением `"Аня"`.

2.  **`$message = 'Привет, $user!\nКак дела?';`**

- Токенизация: `$message`, `=`, `'Привет, $user!\nКак дела?'` (один токен строки!), `;`.

- AST: Узел присваивания переменной `message` строкового литерала.

- Opcodes: `ASSIGN` - создать строку **буквально** из символов между `'` и `'`: `Привет, $user!\nКак дела?` и записать её в `$message`.

- **Важно:** `$user` и `\n` внутри `' '` - это просто текст. Никакой подстановки значения `$user`! Никакой замены `\n` на перенос! В `$message` лежит строка: `Привет, $user!\nКак дела?`.

3.  **`echo $message . "\n" . "<br>";`**

- Токенизация/АST/Opcodes:

- Получить значение `$message` -> `Привет, $user!\nКак дела?` (строка S1).

- Создать строку `"\n"` -> Обработать escape: создать строку из одного символа `LF` (ASCII 10) (строка S2).

- Создать строку `"<br>"` (строка S3).

- Конкатенация: `S1 . S2` -> Новая строка `T1` = `Привет, $user!\nКак дела?` + `LF`.

- Конкатенация: `T1 . S3` -> Новая строка `T2` = `Привет, $user!\nКак дела?LF<br>`.

- `ECHO` - Отправить содержимое `T2` в выходной поток (веб-серверу).

4.  **`echo "Привет, {$user}!\n<br>Как дела?";`**

- Токенизация: `echo`, `"Привет, {$user}!\n<br>Как дела?"`, `;`.

- AST: Узел вывода интерполируемой строки.

- Opcodes (Выполнение строки):

- Начать сборку строки в буфер.

- Добавить `"Привет, "`.

- **Интерполяция:** Найти переменную `$user` -> Значение `"Аня"`. Добавить `"Аня"`.

- Добавить `"!"`.

- **Escape:** `\n` -> Заменить на символ `LF` (добавить `LF`).

- Добавить `"<br>Как дела?"`.

- Создать финальную строку `Result` из буфера: `Привет, Аня!LF<br>Как дела?`.

- `ECHO` - Отправить `Result` в выходной поток.

**Что увидит браузер (Рендеринг HTML):**

- **Первая строка вывода (`echo $message . "\n" . "<br>";`):**

- Текст: `Привет, $user!\nКак дела?` (буквально, т.к. `' '`).

- Символ `LF` (невидим в HTML).

- Тег `<br>` -> **Видимый перенос строки!**

- Итог на экране:

```

Привет, $user!\nКак дела?

[Здесь будет перенос строки из-за <br>]

```

- _(Следующий `echo` будет на новой строке из-за `<br>`)_

- **Вторая строка вывода (`echo "Привет, {$user}!\n<br>Как дела?";`):**

- Текст: `Привет, Аня!` (подставлено значение `$user`).

- Символ `LF` (невидим в HTML).

- Тег `<br>` -> **Видимый перенос строки!**

- Текст: `Как дела?`

- Итог на экране:

```

Привет, Аня! [Пробел из-за коллапсирования \n]

Как дела?   <- На новой строке из-за <br>

```

- _(Обратите внимание, что `\n` между `Аня!` и `<br>` превратился в пробел или ничего, а `<br>` сделал видимый перенос перед `Как дела?`)_

**View Page Source (Исходный код страницы):**

Вы увидите примерно следующее (символ `LF` отображается как новая строка в исходнике):

```

Привет, $user!\nКак дела?

<br>Привет, Аня!

<br>Как дела?

```

**Заключение:**

Понимание разницы между `'` и `"` в PHP сводится к пониманию того, что PHP _делает_ со строкой в момент выполнения:

- **`'строка'`:** "Возьми текст как есть, не трогай ничего внутри. Просто сохрани его."

- **`"строка"`:** "Разбери меня внимательно: найди все `$` и замени их значениями переменных, найди все `\` и выполни указанные ими замены (вроде `\n`->перенос), а потом собери итоговую строку из всех кусочков."
