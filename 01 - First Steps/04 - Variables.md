Ниже — подробный и структурированный разбор всего, что происходит в этом фрагменте курса.

---

## 1. Создание и запуск файла `variables.php`

1. **Создаётся новый файл** в папке проекта, названный `variables.php`.
2. **Открытие в браузере**: при переходе на `http://…/variables.php` сервер обрабатывает этот файл как PHP-код и отдаёт результат в браузер.

---

## 2. Вывод простого текста через `echo`

```php
<?php
echo 'hello php!';
```

- **`echo`** — основная конструкция для вывода данных в PHP.
- Строковый литерал берётся в **одинарные кавычки**.
- **Точка с запятой `;`** сигнализирует об окончании оператора.
- **Закрывающий тег `?>`** здесь опущен — это допустимо, если дальше не идёт HTML-код.

> **Важно:** PHP будет считать весь оставшийся файл частью PHP-кода, если закрывающий тег не указан.

---

## 3. Семантика операторов и переносов строк

```php
echo 'hello php!';
echo 'hello php!';
echo 'hello php!';
```

- PHP разбирает код **по точкам с запятой**, а не по переносу строк.
- Переносы строк и отступы **не влияют** на выполнение, но делают код **читаемым**.

---

## 4. Введение переменных

### 4.1. Объявление переменной

```php
<?php
$greeting = 'hello php';
```

- **Имя переменной** всегда начинается с **`$`**, затем — буквы, цифры или подчёркивания (но не цифра в начале).
- Оператор **`=`** присваивает значение справа (`'hello php'`) переменной слева (`$greeting`).
- **Пробелы** вокруг `=` не влияют на работу, но улучшают читаемость.

### 4.2. Использование переменной в `echo`

```php
echo $greeting;
```

- Вместо литерала строку берёт из переменной.
- При изменении `$greeting` в одном месте, все `echo $greeting;` выводят новое значение.

---

## 5. Демонстрация «силы» переменных

```php
<?php
$greeting = 'hello php on mars';
echo $greeting;
echo $greeting;
echo $greeting;
echo $greeting;
```

- Меняя лишь **одно** присваивание `$greeting = …`, мы автоматически меняем **несколько** мест вывода.

---

## 6. Несколько переменных

```php
<?php
$greeting = 'hello php on mars';
$year     = 2050;

echo $greeting;
echo $year;
```

- Можно одновременно объявлять **сколько угодно** переменных.
- Каждая переменная хранит своё собственное значение любого скалярного типа (строка, число, булево и т.д.).

---

## 7. Переменные внутри HTML-шаблона

Часто PHP-код смешивают с HTML для динамической подстановки данных:

```php
<?php
$title = 'php is amazing';
?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title><?php echo $title; ?></title>
</head>
<body>
  <h1><?php echo $title; ?></h1>
</body>
</html>
```

- В **`<title>`** и в **`<h1>`** выводится одно и то же значение из переменной `$title`.
- При правке `$title` меняются оба места сразу.

---

## 8. Итоги и преимущества переменных

1. **Удобство поддержки**: правим значение в одном месте, изменения распространяются сразу везде.
2. **Читаемость**: вместо «магических» литералов по всему коду используются понятные имена.
3. **Гибкость**: легко подставлять данные в HTML, строить шаблоны, передавать параметры между частями скрипта.

---

Ниже — поэтапное описание того, что происходит «под капотом», когда вы создаёте файл `.php` с HTML и встраиваете в него `<?php … ?>`-блоки.

---

## 1. HTTP-запрос и передача в PHP

1. **Клиент (браузер)** отправляет запрос на URL, например `http://example.com/index.php`.
2. **Веб-сервер** (Apache, Nginx и т. д.) принимает запрос.

   - Если PHP настроен как модуль (mod_php) — сервер сразу же «включает» PHP.
   - Если через FPM (FastCGI Process Manager) — сервер проксирует запрос в отдельный процесс PHP-FPM.

---

## 2. Чтение и препроцессинг файла

1. **PHP-интерпретатор** получает полный текст файла `index.php`.
2. Он **сканирует** файл и делит его на две части:

   - **HTML/текст** вне `<?php … ?>` — остаётся «как есть».
   - **PHP-код** внутри `<?php … ?>` — передаётся на дальнейшую обработку.

Пример разбивки:

```php
<!DOCTYPE html>
<html>
<body>
<?php
  echo "Привет, мир!";
?>
</body>
</html>
```

–>

- Фрагмент 1: `<!DOCTYPE html><html><body>`
- Фрагмент 2: `echo "Привет, мир!";`
- Фрагмент 3: `</body></html>`

---

## 3. Лексический анализ и синтаксический разбор

1. **Лексический анализатор (Tokenizer)** превращает весь PHP-код во **токены** (ключевые слова, идентификаторы, литералы, операторы).
2. **Парсер** формирует из токенов **дерево разбора (AST)** — абстрактное синтаксическое дерево.

---

## 4. Компиляция в «байт-коды» (опкоды)

1. **AST** передаётся в **Zend Engine** (ядро PHP).
2. Zend **компилирует** AST в набор инструкций низкого уровня — **опкодов**.
3. Эти опкоды похожи на машинные команды, но для виртуальной машины PHP.

---

## 5. Исполнение опкодов

1. **Виртуальная машина Zend** последовательно выполняет опкоды.

2. В процессе:

   - **Переменные** создаются и хранятся в **таблице символов** (symbol table).
   - Управляется **выделение и освобождение памяти** (garbage collector).
   - Выполняются функции, методы, операции и т. д.

3. Когда встречается конструкция `echo`, она добавляет строку в **выходной буфер**.

---

## 6. Сборка итогового HTML

1. **HTML-фрагменты** (которые не были внутри `<?php … ?>`) по умолчанию сразу же отправляются в выходной буфер.
2. **Результаты `echo`, `print` и т. п.** тоже попадают в этот же буфер.
3. В результате получается единый поток **готового HTML**.

---

## 7. Отправка ответа клиенту

1. Когда скрипт завершается или достигается конец файла, веб-сервер берёт содержимое выходного буфера.
2. Добавляет HTTP-заголовки (Content-Type, Content-Length и др.) и **отправляет** данные обратно в браузер.

---

## 8. Итоговая схема

```text
Браузер
   ↓ HTTP GET /index.php
Веб-сервер ──▶ PHP-FPM/модуль PHP
   ↓ Чтение index.php
   ↓ Разбиение на HTML / PHP-блоки
   ↓ Токенизация → Парсинг → Компиляция (опкоды)
   ↓ Исполнение опкодов (таблица символов, память, буфер вывода)
   ↓ Формирование итогового HTML
   ↓ HTTP Response
Браузер
```

---

### Почему это важно

- **Разделение HTML и PHP-кода** позволяет удобно генерировать динамический контент.
- **Кеширование опкодов** (OPcache) ускоряет работу, поскольку разбиение/парсинг/компиляция происходят не при каждом запросе.
- Понимание архитектуры помогает:

  - Правильно настраивать сервер (FPM vs mod_php).
  - Оптимизировать производительность (минимизировать тяжёлые операции в PHP-блоках).
  - Безопасно обрабатывать входные данные (опасность «прямого» включения файлов).

---

Теперь вы знаете, как именно PHP берёт файл, разбирает его, компилирует и исполняет — и как в итоге ваш браузер получает сгенерированный HTML.
