### **1. Добавление и изменение элементов**

**Синтаксис:**

```php

$books['Romeo and Juliet'] = 'William Shakespeare'; // Добавление

$books['Romeo and Juliet'] = 'William_Shakespeare'; // Изменение (перезапись)

```

**Объяснение:**

- **Добавление:** Если ключ `'Romeo and Juliet'` отсутствует в массиве, PHP добавит новую пару `ключ => значение`.

- **Изменение (перезапись):** Если ключ уже существует (как в случае с `'Romeo and Juliet'`), PHP заменит старое значение на новое (`'William_Shakespeare'`).

**Внутри PHP (под капотом):**

- **Добавление:**

1. PHP вычисляет **хеш** от ключа (например, `'Romeo and Juliet'`).

2. Находит соответствующий **бакет** в хеш-таблице массива.

3. Если бакет пуст, добавляет новую запись (ключ, значение) и обновляет двусвязный список для сохранения порядка.

- **Изменение:**

1. Аналогично вычисляется хеш ключа.

2. Находит запись в хеш-таблице.

3. **Заменяет значение** на новое, сохраняя ключ и позицию в порядке элементов.

**Важно:** Ключи в ассоциативном массиве **уникальны**. Попытка добавить элемент с существующим ключом всегда приводит к перезаписи значения.

---

### **2. Удаление элементов**

**Синтаксис:**

```php

unset($books['Harry Potter']); // Удаление элемента по ключу

```

**Объяснение:**

- Функция `unset()` удаляет пару `ключ => значение` из массива.

- После удаления, попытка доступа к `$books['Harry Potter']` вернет `null` (и вызовет предупреждение, если ключ не существует).

**Внутри PHP:**

1. Вычисляется хеш ключа `'Harry Potter'`.

2. Находится соответствующий бакет в хеш-таблице.

3. Запись удаляется из хеш-таблицы **и** из двусвязного списка (чтобы сохранить порядок оставшихся элементов).

4. Память, занимаемая записью, освобождается.

---

### **3. Получение размера массива**

**Синтаксис:**

```php

$count = count($books); // Возвращает количество элементов

```

**Объяснение:**

- Функция `count()` работает для ассоциативных массивов так же, как и для числовых. Она возвращает общее количество элементов.

**Внутри PHP:**

- Каждый массив в PHP содержит внутренний счетчик элементов. `count()` просто возвращает это значение (сложность **O(1)** — мгновенно).

---

### **4. Итерация по массиву с помощью `foreach`**

**Варианты:**

- **Только значения:**

```php

foreach ($books as $author) {

var_dump($author); // Выводит только значения (авторов)

}

```

- В переменную `$author` попадают только **значения** (правые части пар).

- **Ключи и значения:**

```php

foreach ($books as $bookTitle => $author) {

var_dump($bookTitle, $author); // Выводит ключ (название) и значение (автор)

}

```

- Здесь `$bookTitle` — ключ элемента, `$author` — значение.

**Рекомендации:**

- Используйте осмысленные имена переменных (например, `$title` и `$author` вместо `$key` и `$value`).

- Если имена неочевидны, допустимо использовать `$key` и `$value`.

**Внутри PHP:**

- `foreach` использует **двусвязный список** массива для итерации в порядке добавления элементов.

- На каждой итерации:

1. PHP берет следующий элемент из внутреннего списка.

2. Копирует его **ключ** и **значение** в указанные переменные (`$bookTitle`, `$author`).

---

### **5. Полезные функции для работы с ключами и значениями**

- **`array_keys($array)`:** Возвращает все ключи массива.

```php

$titles = array_keys($books);

// Результат: ['Harry Potter', 'Lord of the Rings', ...]

```

- _Под капотом:_ PHP создает новый числовой массив и копирует в него все ключи исходного массива (в том же порядке).

- **`array_values($array)`:** Возвращает все значения массива.

```php

$authors = array_values($books);

// Результат: ['J.K. Rowling', 'J.R.R. Tolkien', ...]

```

- _Под капотом:_ Создается новый числовой массив (индексы: 0, 1, 2...), куда копируются значения исходного массива (порядок сохраняется).

**Особенности:**

- Обе функции возвращают **новые массивы**. Исходный массив (`$books`) не изменяется.

- Новые массивы имеют **числовые индексы** (начиная с 0).

**Примеры использования:**

```php

// Только ключи: проверка, есть ли определенный ключ?

if (in_array('Harry Potter', array_keys($books))) {

// ...

}

// Только значения: поиск автора в списке

if (in_array('J.K. Rowling', array_values($books))) {

// ...

}

```

---

### **6. Итерация только по ключам**

**Способ 1: Использовать `array_keys` + цикл**

```php

$titles = array_keys($books);

foreach ($titles as $title) {

var_dump($title);

}

```

**Способ 2: `foreach` с игнорированием значений**

```php

foreach ($books as $title => $_) {

var_dump($title); // Переменная $_ не используется

}

```

- Здесь `$_` — соглашение, указывающее, что значение игнорируется.

---

### **Итоги урока**

1. **Изменение массивов:**

- Добавление: `$arr['new_key'] = 'value';`

- Изменение: `$arr['existing_key'] = 'new_value';` (перезапись).

- Удаление: `unset($arr['key']);`.

2. **Размер массива:** `count($arr)`.

3. **Итерация:**

- `foreach ($arr as $value)` — только значения.

- `foreach ($arr as $key => $value)` — ключи и значения.

4. **Функции:**

- `array_keys()` — получить все ключи.

- `array_values()` — получить все значения (с числовыми индексами).

**Внутренние механизмы:**

- Все операции (добавление, удаление, поиск) используют **хеш-таблицу** для скорости (**O(1)** в среднем).

- Порядок элементов сохраняется благодаря **двусвязному списку**.

- `foreach`, `array_keys`, `array_values` работают с этим списком, чтобы сохранить порядок.

**Осторожно:**

- Ключи уникальны! Повторное использование ключа перезаписывает значение.

- Удаление элементов (`unset`) не сбрасывает числовые индексы в других частях массива (если они есть).

---
