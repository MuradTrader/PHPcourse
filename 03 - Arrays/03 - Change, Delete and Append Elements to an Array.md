### 1. **Изменение элемента массива**

**Текст автора:**

> _"Мы можем изменить элемент массива позже. Например, заменить '&' на 'and'. Для этого обращаемся к элементу по ключу и присваиваем новое значение: `$categories[2] = 'Art and Drawing';`"_

**Что происходит и как это работает:**

- **Механизм:**  
  В PHP массивы реализованы как **упорядоченные хэш-таблицы** (ordered hash maps). Каждый элемент имеет ключ (key) и значение (value).  
  При операции `$array[key] = new_value`:
  1. PHP ищет элемент с указанным ключом в хэш-таблице.
  2. Если ключ существует — значение перезаписывается.
  3. Если ключа нет — создается новый элемент.
- **Пример:**
  ```php
  $categories = [0 => 'Programming', 1 => 'Business', 2 => 'Self-Improvement'];
  $categories[2] = 'Art and Drawing'; // Изменяет элемент с ключом 2
  ```
- **Важно:**  
  Ключи сохраняются! После изменения структура массива остаётся прежней:  
  `[0 => 'Programming', 1 => 'Business', 2 => 'Art and Drawing']`.

---

### 2. **Удаление элементов с помощью `unset()`**

**Текст автора:**

> _"Чтобы удалить элемент, используем `unset($categories[2])`. Но будьте осторожны: ключи не перенумеровываются! Удаленный элемент оставляет 'дыру' в массиве."_

**Что происходит и как это работает:**

- **Механизм:**  
  Функция `unset()` удаляет пару **ключ-значение** из хэш-таблицы.
  - Ключи массива **не переиндексируются** автоматически.
  - Оставшиеся элементы сохраняют свои исходные ключи.
- **Пример:**
  ```php
  $categories = [0 => 'A', 1 => 'B', 2 => 'C', 3 => 'D'];
  unset($categories[2]); // Удаляем элемент с ключом 2
  ```
  Результат: `[0 => 'A', 1 => 'B', 3 => 'D']`.  
  Обратите внимание: ключ `3` остался, а ключ `2` исчез.
- **Проблемы:**
  - При попытке доступа к `$categories[2]` возникнет ошибка `Undefined array key`.
  - Функции вроде `for ($i=0; $i<count($array); $i++)` сломаются из-за пропущенных ключей.

**Рекомендация автора:**

> _"Избегайте `unset()` для индексных массивов, если возможно. Если удаляете элементы — переиндексируйте массив функцией `array_values()`."_

---

### 3. **Добавление элементов с указанием ключа**

**Текст автора:**

> _"Добавим новый элемент с ключом 99: `$categories[99] = 'Nature Books';`. Это создаст 'разрыв' в ключах (после 3 сразу 99)."_

**Что происходит и как это работает:**

- **Механизм:**  
  PHP добавит элемент с указанным ключом, даже если он нарушает последовательность.
  - Если ключ существует — значение перезапишется.
  - Если ключа нет — создастся новый элемент.
- **Пример:**
  ```php
  $categories = [0 => 'A', 1 => 'B', 2 => 'C'];
  $categories[99] = 'Nature Books';
  ```
  Результат: `[0 => 'A', 1 => 'B', 2 => 'C', 99 => 'Nature Books']`.  
  Ключи: `0, 1, 2, 99` (пропущены ключи 3-98).

**Опасность:**

> _"Если вы сделаете опечатку в имени переменной (например, `$categries[99] = ...`), PHP создаст новый массив вместо изменения существующего. Это типичная ошибка!"_

---

### 4. **Автоматическое добавление элементов (без указания ключа)**

**Текст автора:**

> _"Чтобы избежать разрывов, добавляйте элементы так: `$categories[] = 'Nature Books';`. PHP автоматически назначит следующий целочисленный ключ."_

**Что происходит и как это работает:**

- **Механизм:**  
  При синтаксисе `$array[] = value` PHP:
  1. Находит **максимальный целочисленный ключ** в массиве.
  2. Генерирует новый ключ: `max_key + 1`.
  3. Добавляет элемент с этим ключом.
- **Пример:**
  ```php
  $categories = [0 => 'A', 1 => 'B', 2 => 'C'];
  $categories[] = 'D'; // Ключ = max(0,1,2) + 1 = 3
  ```
  Результат: `[0 => 'A', 1 => 'B', 2 => 'C', 3 => 'D']`.

**Особенности:**

- Работает только с **целочисленными ключами**. Если есть строковые ключи — они игнорируются при расчете нового ключа.
- Если массив пуст — новый ключ будет `0`.

---

### 5. **Почему ключи ведут себя так?**

**Объяснение "под капотом":**

- Массивы в PHP — это **не просто списки**, как в некоторых языках. Это **словари (хэш-таблицы)**, где ключи могут быть любыми (int или string).
- Ключи хранятся в оригинальном виде. Функции вроде `count()` или `foreach` перебирают все элементы, но **порядок зависит от порядка добавления**.
- При удалении элемента:
  - Хэш-таблица **освобождает ячейку** для этого ключа.
  - **Индексы других элементов не меняются** (это дорогая операция, PHP её избегает).
- При добавлении без ключа:
  - PHP сканирует массив в поиске **максимального int-ключа** (O(n) сложность).
  - Если ключи не целочисленные — новый ключ будет `0`.

---

### Итоговые рекомендации автора:

1. **Изменение элементов:** Используйте `$array[key] = new_value`.
2. **Удаление элементов:** `unset($array[key])` — осторожно с "дырами".
3. **Добавление элементов:**
   - С указанием ключа: `$array[99] = value` (риск разрывов).
   - Без ключа: `$array[] = value` (лучший вариант для последовательных массивов).
4. **Идеальный сценарий:**  
   Используйте массивы как списки с автоинкрементными ключами — это минимизирует ошибки.

---

**Пример итогового кода из урока:**

```php
$categories = ['Programming', 'Business', 'Self-Improvement', 'History'];

// 1. Изменение элемента
$categories[2] = 'Art and Drawing';

// 2. Удаление элемента (оставляет "дыру")
unset($categories[2]);

// 3. Добавление с указанием ключа (создаёт разрыв)
$categories[99] = 'Nature Books';

// 4. Добавление без ключа (ключ = max_int_key + 1)
$categories[] = 'New Category';
```
