### 1. **Поиск элемента в массиве: array_search()**

**Текст автора:**

> _"Используем array_search() для поиска значения в массиве. Функция возвращает ключ первого найденного элемента."_

**Пример:**

```php

$categories = ['Programming', 'Business', 'Self-Improvement'];

$key = array_search('Business', $categories); // Возвращает 1

```

**Что происходит внутри:**

1. **Линейный поиск:** PHP проходит по массиву от начала до конца, сравнивая каждый элемент с искомым значением (`'Business'`).

2. **Сравнение:** Используется "нестрогое сравнение" (оператор `==`). Для строгого сравнения (тип и значение) передайте третий параметр `true`:

```php

array_search('1', [1, 2, 3]); // 0 (нестрогое сравнение)

array_search('1', [1, 2, 3], true); // false (строгое сравнение)

```

3. **Возврат результата:** При нахождении возвращает ключ элемента. Если элемент не найден, возвращает `false`.

**Эффективность:**

- Сложность O(n) — в худшем случае проверяет все элементы.

- Для больших массивов используйте ассоциативные массивы или структуры данных вроде `SplFixedArray`.

---

### 2. **Выборка части массива: array_slice()**

**Текст автора:**

> _"array_slice() позволяет получить фрагмент массива. Указываем начальный индекс и длину фрагмента."_

**Пример:**

```php

$categories = ['A', 'B', 'C', 'D'];

$slice = array_slice($categories, 1, 2); // ['B', 'C']

```

**Что происходит внутри:**

1. **Параметры:**

- `array`: Исходный массив

- `offset`: Стартовая позиция (отрицательный индекс — отсчет с конца)

- `length`: Длина фрагмента (если не указана — до конца массива)

2. **Создание нового массива:**

- PHP выделяет память под новый массив.

- Копирует элементы из указанного диапазона.

3. **Сохранение ключей:** По умолчанию числовые ключи переиндексируются. Чтобы сохранить оригинальные ключи, передайте `true` четвертым параметром:

```php

array_slice(['a' => 1, 'b' => 2], 0, 1, true); // ['a' => 1]

```

**Особенности:**

- Исходный массив не изменяется.

- Работает за O(k), где k — размер фрагмента.

---

### 3. **Минимум и максимум: min() / max()**

**Текст автора:**

> _"min() и max() работают с числовыми массивами, возвращая минимальное/максимальное значение."_

**Пример:**

```php

$numbers = [1, 5, 8, 10];

$min = min($numbers); // 1

$max = max($numbers); // 10

```

**Что происходит внутри:**

1. **Итерация:** PHP проходит по всем элементам массива.

2. **Сравнение:** Использует внутреннюю функцию сравнения (аналогично оператору `<`).

3. **Возврат:** Возвращает одно значение (первое минимальное/максимальное при нескольких одинаковых).

**Особенности:**

- Для пустого массива возвращает `false` (но генерирует предупреждение).

- Работает и со смешанными типами, но результаты могут быть неожиданными:

```php

min([1, 'hello']); // 1 (числа всегда меньше строк)

min([0, 'hello']); // 'hello' (0 преобразуется в false)

```

---

### 4. **Сумма элементов: array_sum()**

**Текст автора:**

> _"array_sum() вычисляет сумму элементов. Для среднего значения делим сумму на количество элементов."_

**Пример:**

```php

$sum = array_sum($numbers); // 1+5+8+10 = 24

$avg = $sum / count($numbers); // 24 / 4 = 6

```

**Что происходит внутри:**

1. **Итерация:** PHP проходит по массиву, накапливая сумму.

2. **Приведение типов:** Нечисловые значения преобразуются в числа:

- `null` → 0

- `true` → 1, `false` → 0

- Строки → число (если начинается с цифр), иначе 0

3. **Возврат:** Целое число (int) или число с плавающей точкой (float).

**Предостережение:**

```php

array_sum(['10 apples', '5 bananas']); // 15 (строки преобразуются в числа)

array_sum(['apple', 'banana']); // 0 (нечисловые строки)

```

---

### 5. **Объединение массивов: array_merge() и оператор `...`**

**Текст автора:**

> _"array_merge() объединяет массивы. Оператор распаковки `...` делает то же, но с возможностью добавления новых элементов."_

**Синтаксис array_merge():**

```php

$topics = ['Courses', 'Books'];

$topics2 = ['TV', 'Travel'];

$merged = array_merge($topics, $topics2); // ['Courses', 'Books', 'TV', 'Travel']

```

**Что происходит внутри:**

1. **Создание нового массива:**

- Копируются все элементы из первого массива.

- Добавляются элементы из последующих массивов.

2. **Ключи:** Числовые ключи переиндексируются (начинаются с 0). Строковые ключи перезаписываются (последний элемент побеждает).

**Оператор распаковки `...`:**

```php

$merged = [...$topics, ...$topics2, 'Groceries']; // Добавлен новый элемент

```

**Преимущества распаковки:**

- Можно добавлять элементы в любом месте:

```php

$newArray = ['Start', ...$topics, 'Middle', ...$topics2, 'End'];

```

- Работает быстрее `array_merge()` для больших массивов (меньше копирований).

- Поддерживается в аргументах функций (как показано далее).

---

### 6. **Распаковка в аргументах функций**

**Текст автора:**

> _"Оператор `...` распаковывает массив в аргументы функции. Например, передача параметров в round()."_

**Пример:**

```php

$args = [10.123, 1];

$result = round(...$args); // Аналогично round(10.123, 1)

echo $result; // 10.1

```

**Что происходит внутри:**

1. **Распаковка:** Массив `$args` преобразуется в список аргументов.

2. **Вызов функции:** `round()` получает аргументы как если бы они были переданы напрямую.

3. **Гибкость:** Можно комбинировать с обычными аргументами:

```php

$result = round(10.123, ...[1]); // Короткая запись

```

**Ограничения:**

- Число элементов массива должно соответствовать количеству параметров функции.

- Работает только с численно-индексированными массивами (ключи игнорируются).

---

### Сравнение способов объединения массивов

| **Метод** | **Пример** | **Переиндексация ключей?** | **Можно добавлять элементы?** |

|-------------------|------------------------------------|----------------------------|--------------------------------|

| `array_merge()` | `array_merge($a, $b)` | Да (для числовых) | Нет |

| Оператор `...` | `[...$a, ...$b, 'new']` | Да | Да |

| `array_push()` | `array_push($a, ...$b)` | Нет (сохраняет ключи) | Только в конец |

---

### Итоговые выводы:

1. **Поиск:** `array_search()` — простой линейный поиск, O(n).

2. **Срезы:** `array_slice()` создает новый массив (не мутирует исходный).

3. **Агрегация:** `min()`, `max()`, `array_sum()` — удобны для числовых данных.

4. **Объединение:**

- `array_merge()` — классический способ.

- Оператор `...` — современная альтернатива с большей гибкостью.

5. **Распаковка:** Используйте `...` для передачи массива как аргументов функции.
