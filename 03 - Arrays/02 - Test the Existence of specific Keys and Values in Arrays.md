### **1. Попытка доступа к несуществующему элементу массива**

**Код из лекции:**

```php
$categories = ['Programming', 'Design', 'Business'];
var_dump($categories[100]); // Обращение к 100-му элементу
```

**Что происходит:**

- PHP пытается найти элемент с индексом `100` в массиве `$categories`.
- Такого элемента **не существует** (массив содержит только 3 элемента с индексами 0, 1, 2).
- **Внутри PHP:**  
  Интерпретатор ищет ключ `100` в хеш-таблице (внутренняя структура данных массива). Если ключ отсутствует:
  1. Генерируется **предупреждение (E_WARNING)**: `Undefined array key 100`.  
     (Это не останавливает выполнение скрипта, в отличие от ошибок).
  2. Возвращается значение **`null`** – специальный тип данных, означающий "отсутствие значения".

**Результат в браузере:**

```
Warning: Undefined array key 100 in ...
NULL
```

**Важно:**

- `null` – это отдельный тип данных. Его можно явно задать:
  ```php
  $var = null; // или $var = NULL; (регистронезависим)
  ```
- Предупреждения видны в выводе – это сигнал о потенциальной ошибке в коде. Их нужно избегать.

---

### **2. Проверка существования ключа в массиве**

**Код из лекции:**

```php
var_dump(isset($categories[99])); // Проверка ключа 99
var_dump(empty($categories[99])); // Проверка "пустоты" ключа 99
```

**Функции и их поведение:**

1. **`isset($array[key])`:**

   - Проверяет:
     - Существует ли ключ `key` в массиве.
     - Не равен ли его значению `null`.
   - Возвращает `true`, только если ключ есть **и** значение не `null`.
   - **Внутри PHP:** Быстрая проверка хеш-таблицы массива на наличие ключа.

2. **`empty($array[key])`:**
   - Проверяет, является ли значение "пустым". Возвращает `true` для:
     - Несуществующих ключей.
     - Значений: `null`, `false`, `0`, `""`, `[]` (пустой массив).
   - **Важно:** Для несуществующего ключа `empty()` вернет `true` без предупреждения!

**Пример вывода для `$categories = ['Programming', 'Design', 'Business']`:**

```php
var_dump(isset($categories[99]));  // bool(false) - ключа нет
var_dump(empty($categories[99]));  // bool(true) - ключа нет (это считается "пустым")
```

---

### **3. Проверка существования значения в массиве**

**Код из лекции:**

```php
in_array('Programming', $categories); // true
in_array('German books', $categories); // false
```

**Функция `in_array($needle, $haystack)`:**

- Ищет значение `$needle` в массиве `$haystack`.
- Возвращает `true`, если значение найдено, иначе `false`.
- **Внутри PHP:**  
  Происходит линейный поиск по массиву. Каждый элемент сравнивается с `$needle`.
  - Для больших массивов это может быть медленнее, чем проверка ключа (где используется хеш-таблица).
- **Чувствительность к типу данных:**  
  По умолчанию `in_array()` использует "гибкое" сравнение (`==`). Если нужно строгое (`===`), добавьте третий параметр:
  ```php
  in_array(0, ['a', 'b']);      // true (0 == 'a' -> false, но 0 == false -> ? Будьте осторожны!)
  in_array(0, ['a', 'b'], true); // false (строгое сравнение: 0 !== 'a', 0 !== 'b')
  ```

---

### **4. Подсчет элементов массива**

**Код из лекции:**

```php
count($categories); // Возвращает 3
```

**Функция `count($array)`:**

- Возвращает количество элементов в массиве.
- **Внутри PHP:**  
  Интерпретатор обращается к внутреннему счетчику массива (структура `zend_array` хранит число элементов). Это **очень быстрая** операция (O(1)).
- Для пустого массива вернет `0`.

---

### **5. Разница между ключами (keys) и значениями (values)**

**Ключи:**

- Индексы для доступа к элементам (например, `0`, `1`, `2` в примере).
- Могут быть целыми числами (индексированные массивы) или строками (ассоциативные массивы).
- Проверяются через **`isset()`/`array_key_exists()`**.

**Значения:**

- Данные, хранящиеся в массиве (`'Programming'`, `'Design'` и т.д.).
- Проверяются через **`in_array()`**.

**Визуализация массива:**

```php
$categories = [
    0 => 'Programming', // Ключ 0, Значение 'Programming'
    1 => 'Design',      // Ключ 1, Значение 'Design'
    2 => 'Business'     // Ключ 2, Значение 'Business'
];
```

---

### **6. Практическое применение (как в лекции)**

**Проверка категории перед использованием:**

```php
$userCategory = $_POST['category']; // Допустим, пользователь ввел "Design"

if (in_array($userCategory, $categories)) {
    echo "$userCategory is a valid category on our system!";
} else {
    echo "Invalid category!";
}
```

- **Зачем:** Защита от передачи несуществующих категорий (например, из формы).

---

### **Ключевые выводы и рекомендации**

1. **Всегда проверяйте существование ключа** перед доступом:  
   Используйте `isset()` или `array_key_exists()` для избежания предупреждений.
2. **Выбор между `isset()` и `empty()`:**
   - `isset()` – для проверки существования ключа.
   - `empty()` – для проверки "наличия полезного значения" (учитывает 0, `null`, пустые строки).
3. **Поиск по значению (`in_array()`)** медленнее, чем **поиск по ключу** (`isset()`). Используйте ключи для частых проверок.
4. **`count()` эффективен** – не бойтесь его использовать даже для больших массивов.
5. **Настройте окружение:**  
   В продакшене отключайте вывод предупреждений (настройка `error_reporting` в `php.ini`), но всегда исправляйте их в коде.
